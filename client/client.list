ca65 V2.16 - Git f5e9b401
Main file   : client.s
Current file: client.s

000000r 1               PADDLE_SUPPORT = 1
000000r 1               ;;; MOUSE_SUPPORT  = 1
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Super Serial constants/locations
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               ;;; These get incremented by the slot where they appear
000000r 1               UACTRL   = $C08B   ; Control Register
000000r 1               UACMND   = $C08A   ; Command Register
000000r 1               UASTAT   = $C089   ; Status Register
000000r 1               UADATA   = $C088   ; Data Register - incoming and outgoing data
000000r 1               
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Hi-res graphics constants/locations
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               PLOTPAGE  = $E6 ; Active hires plotting page (Applesoft)
000000r 1               PLOTPAGE1 = $20
000000r 1               PLOTPAGE2 = $40
000000r 1               PAGESIZE  = $20 ; Size of hi-res screen in pages
000000r 1               
000000r 1               
000000r 1               CLRTEXT  = $C050 ;display graphics
000000r 1               SETTEXT  = $C051 ;display text
000000r 1               CLRMIXED = $C052 ;clear mixed mode- enable full graphics
000000r 1               SETMIXED = $C053 ;enable graphics/text mixed mode
000000r 1               PAGE1    = $C054 ;select text/graphics page1
000000r 1               PAGE2    = $C055 ;select text/graphics page2
000000r 1               CLRHIRES = $C056 ;select Lo-res
000000r 1               SETHIRES = $C057 ;select Hi-res
000000r 1               
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Keyboard input constants/locations
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               KEYBD     =   $C000 ; key down in bit 7; key code in lower bits
000000r 1               STROBE    =   $C010 ; write to clear key down state
000000r 1               OPNAPPLE  =   $C061 ; open apple (command) key data (read)
000000r 1               CLSAPPLE  =   $C062 ; closed apple (option) key data (read)
000000r 1               PB2       =   $C063 ; Paddle button 2 (read)
000000r 1               PB3       =   $C060 ; Paddle button 3 (read)
000000r 1               
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Paddle/Joystick constants/locations/routines
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               PADDLE0 =  $C064    ; bit 7 = status of pdl-0 timer (read)
000000r 1               PADDLE1 =  $C065    ; bit 7 = status of pdl-1 timer (read)
000000r 1               PADDLE2 =  $C066    ; bit 7 = status of pdl-2 timer (read)
000000r 1               PADDLE3 =  $C067    ; bit 7 = status of pdl-3 timer (read)
000000r 1               PDLTRIG =  $C070    ; trigger paddles
000000r 1               
000000r 1               PREAD   =  $FB1E    ; Monitor paddle reading routine, call
000000r 1                                   ; with paddle # in X, returns value in Y
000000r 1               
000000r 1               
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Other
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               SLOT_CASE =   $c000 ; Firmware for slots are at $cx00
000000r 1               MAX_SLOT  =   7     ; Maximum slot # on an Apple II
000000r 1               
000000r 1               ZP        =   $FA   ; Write cursor location on zero page
000000r 1               ESCAPE    =   $80   ; Unused image data byte (all black2)
000000r 1               ESCAPE2   =   $FF   ; Unused image data byte (all white2)
000000r 1               
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Generic Macros
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               ;;;----------------------------------------
000000r 1               .macro SaveRegisters
000000r 1               ;;;----------------------------------------
000000r 1                   pha
000000r 1                   txa
000000r 1                   pha
000000r 1                   tya
000000r 1                   pha
000000r 1               .endmacro
000000r 1               
000000r 1               ;;;----------------------------------------
000000r 1               .macro RestoreRegisters
000000r 1               ;;;----------------------------------------
000000r 1                   pla
000000r 1                   tay
000000r 1                   pla
000000r 1                   tax
000000r 1                   pla
000000r 1               .endmacro
000000r 1               
000000r 1               
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               ;
000000r 1               ;;; Application-level logic
000000r 1               ;
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               
000000r 1               
000000r 1               .org $6000
006000  1  4C 54 60             jmp AppEntry
006003  1               
006003  1               .include "ssc.inc"
006003  2               ;;;-------------------------------------------------------------------
006003  2               ;;;
006003  2               ;;; Serial port routines
006003  2               ;;;
006003  2               ;;; (based on ADTPro)
006003  2               ;;;
006003  2               ;;;-------------------------------------------------------------------
006003  2               
006003  2               .proc SSC
006003  2               
006003  2               ;;;---------------------------------------------------------
006003  2               .proc Init
006003  2               ;;;---------------------------------------------------------
006003  2               ;;; Initialize the SSC; slot passed in A
006003  2               ;;;---------------------------------------------------------
006003  2  0A               asl                 ; Slot passed in A
006004  2  0A               asl
006005  2  0A               asl
006006  2  0A               asl	    	        ; Now $S0
006007  2  69 88            adc #$88            ; Low byte of UADATA
006009  2  AA               tax
00600A  2  A9 0B            lda #CMND_NRDI      ; Command register: no parity, RTS on, DTR on, no interrupts
00600C  2  9D 02 C0         sta $C002,X
00600F  2  AC C9 61         ldy PSPEED	        ; Control register: look up by baud rate (8 data bits, 1 stop bit)
006012  2  B9 C5 61         lda BPSCTRL,Y
006015  2  9D 03 C0         sta $C003,X
006018  2  8E 38 60         stx MOD_UADATA_1+1	; Modify references to
00601B  2  8E 45 60         stx MOD_UADATA_2+1	; UADATA to point at
00601E  2  8E 51 60         stx MOD_UADATA_3+1	; correct slot (UADATA+S0)
006021  2  E8               inx
006022  2  8E 2E 60         stx MOD_UASTAT_1+1	; Modify reference to
006025  2  8E 3C 60         stx MOD_UASTAT_2+1	; UASTAT to point at
006028  2  8E 49 60         stx MOD_UASTAT_3+1  ; correct slot (UASTAT+S0)
00602B  2  60               rts
00602C  2               
00602C  2               .endproc
00602C  2               
00602C  2               
00602C  2               ;;;---------------------------------------------------------
00602C  2               .proc Put
00602C  2               ;;;---------------------------------------------------------
00602C  2               ;;; Send accumulator out the serial port
00602C  2               ;;;---------------------------------------------------------
00602C  2  48               pha		    ; Push A onto the stack
00602D  2               MOD_UASTAT_1:
00602D  2  AD 89 C0     :   lda UASTAT	; Check status bits
006030  2  29 70            and #$70
006032  2  C9 10            cmp #$10
006034  2  D0 F7            bne :-  	; Output register is full, so loop
006036  2  68               pla
006037  2               MOD_UADATA_1:
006037  2  8D 88 C0         sta UADATA	; Put character
00603A  2  60               rts
00603B  2               .endproc
00603B  2                       MOD_UASTAT_1 := Put::MOD_UASTAT_1
00603B  2                       MOD_UADATA_1 := Put::MOD_UADATA_1
00603B  2               
00603B  2               ;;;---------------------------------------------------------
00603B  2               .proc Get
00603B  2               ;;;---------------------------------------------------------
00603B  2               ;;; Read a character from the serial port to the accumulator
00603B  2               ;;;---------------------------------------------------------
00603B  2               MOD_UASTAT_2:
00603B  2  AD 89 C0     	lda UASTAT	; Check status bits
00603E  2  29 68            and #$68
006040  2  C9 08            cmp #$8
006042  2  D0 F7            bne Get	; Input register empty, loop
006044  2               MOD_UADATA_2:
006044  2  AD 88 C0     	lda UADATA	; Get character
006047  2  60               rts
006048  2               .endproc
006048  2                       MOD_UASTAT_2 := Get::MOD_UASTAT_2
006048  2                       MOD_UADATA_2 := Get::MOD_UADATA_2
006048  2               
006048  2               ;;;---------------------------------------------------------
006048  2               .proc HasData
006048  2               ;;;---------------------------------------------------------
006048  2               ;;; Read a character from the serial port to the accumulator
006048  2               ;;;---------------------------------------------------------
006048  2               MOD_UASTAT_3:
006048  2  AD 89 C0     	lda UASTAT	; Check status bits
00604B  2  29 68            and #$68
00604D  2  C9 08            cmp #$8
00604F  2  60               rts
006050  2               .endproc
006050  2                       MOD_UASTAT_3 := HasData::MOD_UASTAT_3
006050  2               
006050  2               
006050  2               ;;;---------------------------------------------------------
006050  2               .proc Reset
006050  2               ;;;---------------------------------------------------------
006050  2               ;;; Clean up serial port
006050  2               ;;;---------------------------------------------------------
006050  2               MOD_UADATA_3:
006050  2  2C 88 C0     	bit UADATA
006053  2  60               rts
006054  2               .endproc
006054  2                       MOD_UADATA_3 := Reset::MOD_UADATA_3
006054  2               
006054  2               .endproc
006054  2               
006054  1               
006054  1               .ifdef MOUSE_SUPPORT
006054  1                       .include "mouse.inc"
006054  1               .endif ; MOUSE_SUPPORT
006054  1               
006054  1               
006054  1               ;;;---------------------------------------------------------
006054  1               .proc AppEntry
006054  1               ;;;---------------------------------------------------------
006054  1               ;;; Initialize the application, and enter the main loop
006054  1               ;;;---------------------------------------------------------
006054  1  AD CA 61         lda PSLOT          ; Use slot 2
006057  1  20 03 60         jsr SSC::Init      ; Initialize Super Serial Card
00605A  1  20 80 61         jsr InitHires      ; Initialize Hi-Res graphics
00605D  1  20 94 60         jsr InitInput      ; Initialize input devices
006060  1  20 6D 60         jsr MainLoop
006063  1               
006063  1                   ; fall through
006063  1               .endproc
006063  1               
006063  1               ;;;---------------------------------------------------------
006063  1               .proc AppExit
006063  1               ;;;---------------------------------------------------------
006063  1               ;;; Clean up and exit app
006063  1               ;;;---------------------------------------------------------
006063  1  20 50 60         jsr SSC::Reset
006066  1  8D 54 C0         sta PAGE1
006069  1  8D 51 C0         sta SETTEXT
00606C  1  60               rts
00606D  1               .endproc
00606D  1               
00606D  1               
00606D  1               ;;;-------------------------------------------------------------------
00606D  1               ;
00606D  1               ;;; Main loop functionality
00606D  1               ;
00606D  1               ;;;-------------------------------------------------------------------
00606D  1               
00606D  1               
00606D  1               ;;;---------------------------------------------------------
00606D  1               .proc MainLoop
00606D  1               ;;;---------------------------------------------------------
00606D  1               
00606D  1               ;;; TODO: Sort out the protocol - should be able to send
00606D  1               ;;; input state without receiving data
00606D  1               ;;;    jsr SSCHasData      ; Anything to read?
00606D  1               ;;;    bne :+              ; Nope
00606D  1               
00606D  1  20 77 60     :   jsr ReceivePage
006070  1  20 97 61         jsr FlipHires
006073  1  4C 6D 60         jmp :-              ; TODO: define an exit trigger
006076  1  60               rts
006077  1               .endproc
006077  1               
006077  1               
006077  1               ;;;---------------------------------------------------------
006077  1               .proc ReceivePage
006077  1               ;;;---------------------------------------------------------
006077  1               ;;; Pull a hi-res page down over serial
006077  1               ;
006077  1               ;;; Protocol is:
006077  1               ;;;  * Recieve 256 bytes (graphic data)
006077  1               ;;;  * Send 1 byte (input state)
006077  1               ;;;---------------------------------------------------------
006077  1               
006077  1  A9 00            lda #0        ; set up write pointer
006079  1  85 FA            sta ZP
00607B  1  A5 E6            lda PLOTPAGE
00607D  1  85 FB            sta ZP+1
00607F  1  A2 20            ldx #PAGESIZE ; plan to receive this many pages
006081  1  A0 00            ldy #0
006083  1               
006083  1  20 3B 60     :   jsr SSC::Get  ; TODO: look for escape codes in the sequence
006086  1  91 FA            sta (ZP),Y
006088  1  C8               iny
006089  1  D0 F8            bne :-       ; Do a full page...
00608B  1               
00608B  1  20 B2 60         jsr SendInputState ; brief moment to send data back upstream
00608E  1               
00608E  1  E6 FB            inc ZP+1
006090  1  CA               dex
006091  1  D0 F0            bne :-       ; ...as many pages as we need
006093  1  60               rts
006094  1               .endproc
006094  1               
006094  1               
006094  1               ;;;-------------------------------------------------------------------
006094  1               ;
006094  1               ;;; Input device routines
006094  1               ;
006094  1               ;;;-------------------------------------------------------------------
006094  1               ;;; Protocol:
006094  1               ;;;  $7f - $ff - key down, ASCII code + $80
006094  1               ;;;  otherwise, a transition:
006094  1               ;
006094  1                   SIS_KBUP    = $00   ; Key up
006094  1                   SIS_OADOWN  = $01   ; Open Apple transitioned to down
006094  1                   SIS_OAUP    = $02   ; Open Apple transitioned to up
006094  1                   SIS_CADOWN  = $03   ; Closed Apple transitioned to down
006094  1                   SIS_CAUP    = $04   ; Closed Apple transitioned to up
006094  1               ;
006094  1               ;;;  $05 - $0f : reserved
006094  1               ;
006094  1                   SIS_MX      = $10   ; Mouse X high nibble
006094  1                   SIS_MY      = $20   ; Mouse Y high nibble
006094  1                   SIS_PDL0    = $30   ; Paddle 0 high nibble
006094  1                   SIS_PDL1    = $40   ; Paddle 1 high nibble
006094  1               ;
006094  1               ;;;  $50 - $7e : reserved
006094  1               ;
006094  1                   SIS_SYNC    = $7f
006094  1               
006094  1               ;;;---------------------------------------------------------
006094  1               .proc InitInput
006094  1               ;;;---------------------------------------------------------
006094  1               ;;; Initialize input devices and storage for detecting
006094  1               ;;; state transitions
006094  1               ;;;---------------------------------------------------------
006094  1               
006094  1               ;;; Init keyboard state
006094  1  A9 00            lda #SIS_KBUP
006096  1  8D CC 61         sta LASTKB
006099  1               
006099  1               ;;; Init Open/Closed Apple states
006099  1  A9 02            lda #SIS_OAUP       ; NOTE: Don't store OA state as it fluctuates
00609B  1  8D CD 61         sta LASTOA
00609E  1  A9 04            lda #SIS_CAUP       ; NOTE: Don't store CA state as it fluctuates
0060A0  1  8D CE 61         sta LASTCA
0060A3  1               
0060A3  1               .ifdef PADDLE_SUPPORT
0060A3  1               ;;; Init Paddle state
0060A3  1  A9 30            lda #SIS_PDL0
0060A5  1  09 08            ora #8              ; Middle of range 0...15
0060A7  1  8D CF 61         sta LASTP0
0060AA  1  A9 40            lda #SIS_PDL1
0060AC  1  09 08            ora #8              ; Middle of range 0...15
0060AE  1  8D D0 61         sta LASTP1
0060B1  1               .endif
0060B1  1               
0060B1  1               .ifdef MOUSE_SUPPORT
0060B1  1                   jsr Mouse::FindMouse
0060B1  1               .endif
0060B1  1               
0060B1  1  60               rts
0060B2  1               .endproc
0060B2  1               
0060B2  1               
0060B2  1               ;;;---------------------------------------------------------
0060B2  1               .proc SendInputState
0060B2  1               ;;;---------------------------------------------------------
0060B2  1               ;;; Send keyboard joystick and/or mouse state over the
0060B2  1               ;;; serial port
0060B2  1               ;
0060B2  1               ;;; Algorithm:
0060B2  1               ;;; - Send key state (if it changed)
0060B2  1               ;;; - otherwise send open-apple state (if it changed)
0060B2  1               ;;; - otherwise send closed-apple state (if it changed)
0060B2  1               ;;; - otherwise send paddle 0 state (if it changed)
0060B2  1               ;;; - (TODO: Mouse state)
0060B2  1               ;;; - otherwise send sync byte
0060B2  1               ;;;---------------------------------------------------------
0060B2  1               
0060B2  1  48 8A 48 98      SaveRegisters       ; Store registers
0060B6  1  48           
0060B7  1  18               clc
0060B8  1               
0060B8  1               ;;;--------------------------------------
0060B8  1               ;;; Send key state, if it changed
0060B8  1               
0060B8  1               ;;; NOTE: Can't use STROBE to detect key up -> key down transition
0060B8  1               ;;; since the msb can change before the key code. Instead, consider
0060B8  1               ;;; these cases:
0060B8  1               ;
0060B8  1               ;;;  OLD STATE    KEYBD     STROBE     RESULT
0060B8  1               ;;;   Up           Up        -          No-op
0060B8  1               ;;;   Up           Down      -          Save and send key down
0060B8  1               ;;;   Down         -         Up         Save and send key up
0060B8  1               ;;;   Down         -         Down       Save and send key ONLY if different
0060B8  1               ;
0060B8  1               
0060B8  1  AD CC 61         lda LASTKB
0060BB  1  D0 0E            bne KEY_WAS_DOWN
0060BD  1               
0060BD  1               KEY_WAS_UP:
0060BD  1  AD 00 C0         lda KEYBD           ; Read keyboard
0060C0  1  10 27            bpl END_KEY         ; - still up
0060C2  1  8D CC 61         sta LASTKB          ; Down, so save it
0060C5  1  20 2C 60         jsr SSC::Put          ; and send it
0060C8  1  4C 7A 61         jmp DONE
0060CB  1               
0060CB  1               KEY_WAS_DOWN:
0060CB  1                   ; key was down - strobe should match
0060CB  1                   ; unless the key changed or was released
0060CB  1  AD 10 C0         lda STROBE
0060CE  1  30 0B            bmi STROBE_DOWN
0060D0  1               STROBE_UP:
0060D0  1  A9 00            lda #SIS_KBUP       ; Key was released
0060D2  1  8D CC 61         sta LASTKB          ; so save it
0060D5  1  20 2C 60         jsr SSC::Put          ; and send it
0060D8  1  4C 7A 61         jmp DONE
0060DB  1               STROBE_DOWN:
0060DB  1  CD CC 61         cmp LASTKB          ; Same key as last time?
0060DE  1  F0 09            beq END_KEY         ; - no change
0060E0  1  8D CC 61         sta LASTKB          ; New key, so save it
0060E3  1  20 2C 60         jsr SSC::Put          ; and send it
0060E6  1  4C 7A 61         jmp DONE
0060E9  1               
0060E9  1               END_KEY:
0060E9  1               
0060E9  1               ;;;--------------------------------------
0060E9  1               ;;; Send Open Apple state, if it changed
0060E9  1               
0060E9  1               ;;; TODO: Can simplify this code if we make the high bits the same
0060E9  1               ;;; for both OA states and bit = 0 down: lda OPNAPPLE ; ROL ; LDA #0 ; ROL ; ORA #signature
0060E9  1               
0060E9  1               TEST_OA:
0060E9  1  AD 61 C0         lda OPNAPPLE        ; Test Open Apple state
0060EC  1  30 10            bmi OA_IS_DOWN
0060EE  1               OA_IS_UP:
0060EE  1  A9 02            lda #SIS_OAUP
0060F0  1  CD CD 61         cmp LASTOA          ; Changed?
0060F3  1  F0 19            beq END_OA          ; Nope
0060F5  1  8D CD 61         sta LASTOA          ; Yes, save it / send it!
0060F8  1  20 2C 60         jsr SSC::Put
0060FB  1  4C 7A 61         jmp DONE
0060FE  1               OA_IS_DOWN:
0060FE  1  A9 01            lda #SIS_OADOWN
006100  1  CD CD 61         cmp LASTOA          ; Changed?
006103  1  F0 09            beq END_OA          ; Nope
006105  1  8D CD 61         sta LASTOA          ; Yes, save it / send it!
006108  1  20 2C 60         jsr SSC::Put
00610B  1  4C 7A 61         jmp DONE
00610E  1               
00610E  1               END_OA:
00610E  1               
00610E  1               ;;;--------------------------------------
00610E  1               ;;; Send Closed Apple state, if it changed
00610E  1               
00610E  1               TEST_CA:
00610E  1  AD 62 C0         lda CLSAPPLE        ; Has the Open Apple/Button 1 value changed?
006111  1  30 10            bmi CA_IS_DOWN
006113  1               CA_IS_UP:
006113  1  A9 04            lda #SIS_CAUP
006115  1  CD CE 61         cmp LASTCA          ; Changed?
006118  1  F0 19            beq END_CA          ; Nope
00611A  1  8D CE 61         sta LASTCA          ; Yes, save it
00611D  1  20 2C 60         jsr SSC::Put          ; and send it
006120  1  4C 7A 61         jmp DONE
006123  1               CA_IS_DOWN:
006123  1  A9 03            lda #SIS_CADOWN
006125  1  CD CE 61         cmp LASTCA          ; Changed?
006128  1  F0 09            beq END_CA          ; Nope
00612A  1  8D CE 61         sta LASTCA          ; Yes, save it
00612D  1  20 2C 60         jsr SSC::Put          ; and send it
006130  1  4C 7A 61         jmp DONE
006133  1               
006133  1               END_CA:
006133  1               
006133  1               .ifdef PADDLE_SUPPORT
006133  1               
006133  1               ;;;--------------------------------------
006133  1               ;;; Send Paddle 0 state, if it changed
006133  1               TEST_PDL0:
006133  1  A2 00            ldx #0
006135  1  20 1E FB         jsr PREAD
006138  1  98               tya
006139  1  4A               lsr                 ; Shift to low nibble
00613A  1  4A               lsr
00613B  1  4A               lsr
00613C  1  4A               lsr
00613D  1  09 30            ora #SIS_PDL0       ; And mark it with the signature
00613F  1  CD CF 61         cmp LASTP0          ; Change?
006142  1  F0 09            beq END_PDL0        ; Nope
006144  1  8D CF 61         sta LASTP0          ; Yes, save it
006147  1  20 2C 60         jsr SSC::Put          ; and send it
00614A  1  4C 7A 61         jmp DONE
00614D  1               END_PDL0:
00614D  1                   ; Chew up time so next paddle read will be correct
00614D  1                   ; TODO: Replace this with a "read both" strobes
00614D  1                   ; routine
00614D  1  EA EA EA EA  :   .repeat 11          ; By experiment, need 11 NOPs.
006151  1  EA EA EA EA  
006155  1  EA EA EA     
006158  1                   nop
006158  1                   .endrep
006158  1  C8               iny
006159  1  D0 F2            bne :-
00615B  1               
00615B  1               ;;;--------------------------------------
00615B  1               ;;; Send Paddle 1 state, if it changed
00615B  1               TEST_PDL1:
00615B  1  A2 01            ldx #1
00615D  1  20 1E FB         jsr PREAD
006160  1  98               tya
006161  1  4A               lsr                 ; Shift to low nibble
006162  1  4A               lsr
006163  1  4A               lsr
006164  1  4A               lsr
006165  1  09 40            ora #SIS_PDL1       ; And mark it with the signature
006167  1  CD D0 61         cmp LASTP1          ; Change?
00616A  1  F0 09            beq END_PDL1        ; Nope
00616C  1  8D D0 61         sta LASTP1          ; Yes, save it
00616F  1  20 2C 60         jsr SSC::Put          ; and send it
006172  1  4C 7A 61         jmp DONE
006175  1               END_PDL1:
006175  1                   ; NOTE: No need to chew time like PDL0
006175  1                   ; since data receive will make up for it; if we
006175  1                   ; loop in SendInputState need to add it here
006175  1               
006175  1               .endif
006175  1               
006175  1               
006175  1               ;;;--------------------------------------
006175  1               ;;; No state changes so send sync byte
006175  1               
006175  1  A9 7F            lda #SIS_SYNC
006177  1  20 2C 60         jsr SSC::Put
00617A  1               
00617A  1               DONE:
00617A  1  68 A8 68 AA      RestoreRegisters
00617E  1  68           
00617F  1  60               rts
006180  1               
006180  1               .endproc
006180  1               
006180  1               
006180  1               ;;;-------------------------------------------------------------------
006180  1               ;
006180  1               ;;; Hi-res graphics routines
006180  1               ;
006180  1               ;;;-------------------------------------------------------------------
006180  1               
006180  1               ;;;---------------------------------------------------------
006180  1               .proc InitHires
006180  1               ;;;---------------------------------------------------------
006180  1               ;;; Set up the graphics display and pointers
006180  1               ;;;---------------------------------------------------------
006180  1  A9 20            lda #PLOTPAGE1   ; clear page 1
006182  1  85 E6            sta PLOTPAGE
006184  1  20 AD 61         jsr ClearHires
006187  1               
006187  1  20 97 61         jsr FlipHires    ; then show it and flip to 2
00618A  1  8D 57 C0         sta SETHIRES
00618D  1  8D 50 C0         sta CLRTEXT
006190  1  8D 52 C0         sta CLRMIXED
006193  1  8D 54 C0         sta PAGE1
006196  1               
006196  1  60               rts
006197  1               .endproc
006197  1               
006197  1               
006197  1               ;;;---------------------------------------------------------
006197  1               .proc FlipHires
006197  1               ;;;---------------------------------------------------------
006197  1               ;;; Call when done with the current plotting page
006197  1               ;;; (selected in PLOTPAGE) and it will be shown and the
006197  1               ;;; other page will be shown.
006197  1               ;;;---------------------------------------------------------
006197  1  A5 E6            lda PLOTPAGE        ; plotting on which page?
006199  1  C9 20            cmp #PLOTPAGE1
00619B  1  F0 08            beq :+
00619D  1               
00619D  1  8D 55 C0         sta PAGE2           ; page 2 - so show it
0061A0  1  A9 20            lda #PLOTPAGE1      ; and plot on page 1
0061A2  1  85 E6            sta PLOTPAGE
0061A4  1  60               rts
0061A5  1               
0061A5  1  8D 54 C0     :   sta PAGE1           ; page 1 - so show it
0061A8  1  A9 40            lda #PLOTPAGE2      ; and plot on page 2
0061AA  1  85 E6            sta PLOTPAGE
0061AC  1  60               rts
0061AD  1               .endproc
0061AD  1               
0061AD  1               
0061AD  1               ;;;---------------------------------------------------------
0061AD  1               .proc ClearHires
0061AD  1               ;;;---------------------------------------------------------
0061AD  1               ;;; Clear hires plotting page (selected in PLOTPAGE) to
0061AD  1               ;;; black uses ZP; not terribly efficient
0061AD  1               ;;;---------------------------------------------------------
0061AD  1  A9 00           lda #0           ; Set up ZP as a pointer into the hires page
0061AF  1  85 FA           sta ZP
0061B1  1  A5 E6           lda PLOTPAGE
0061B3  1  85 FB           sta ZP+1
0061B5  1  A2 20           ldx #PAGESIZE    ; Clear this many pages
0061B7  1  A9 00           lda #0           ; with black!
0061B9  1  A8              tay
0061BA  1  91 FA        :  sta (ZP),Y
0061BC  1  C8              iny
0061BD  1  D0 FB           bne :-
0061BF  1  E6 FB           inc ZP+1
0061C1  1  CA              dex
0061C2  1  D0 F6           bne :-
0061C4  1  60              rts
0061C5  1               .endproc
0061C5  1               
0061C5  1               
0061C5  1               
0061C5  1               
0061C5  1               ;;;-------------------------------------------------------------------
0061C5  1               ;
0061C5  1               ;;; Lookup Tables and Variable Storage
0061C5  1               ;
0061C5  1               ;;;-------------------------------------------------------------------
0061C5  1               
0061C5  1               ;;; Lookup table for UACTRL register, by baud rate
0061C5  1               
0061C5  1  16 1E 1F 10  BPSCTRL:	.byte $16,$1E,$1F,$10	; 300, 9600, 19200, 115k (with 8 data bits, 1 stop bit, no echo)
0061C9  1               .enum
0061C9  1                   BPS_300
0061C9  1                   BPS_9600
0061C9  1                   BPS_19200
0061C9  1                   BPS_115k
0061C9  1               .endenum
0061C9  1               CMND_NRDI    = $0B    ; Command: no parity, RTS on, DTR on, no interrupts
0061C9  1               
0061C9  1               
0061C9  1               ;;; Application configuration
0061C9  1  03           PSPEED:     .byte BPS_115k  ; Hardcoded for Apple IIc (TODO: Allow configuration)
0061CA  1  02           PSLOT:      .byte 2         ; Hardcoded for Apple IIc (TODO: Allow configuration)
0061CB  1  00           PEXIT:      .byte 0         ; Set when it's time to exit (Not Yet Implemented)
0061CC  1               
0061CC  1               
0061CC  1               ;;; Keyboard state
0061CC  1  00           LASTKB:     .byte 0
0061CD  1  00           LASTOA:     .byte 0
0061CE  1  00           LASTCA:     .byte 0
0061CF  1               
0061CF  1               .ifdef PADDLE_SUPPORT
0061CF  1               
0061CF  1               ;;; Paddle state
0061CF  1  00           LASTP0:     .byte 0
0061D0  1  00           LASTP1:     .byte 0
0061D1  1               
0061D1  1               .endif ; PADDLE_SUPPORT
0061D1  1               
