ca65 V2.16 - Git f5e9b401
Main file   : client.s
Current file: client.s

000000r 1               ;;;-------------------------------------------------------------------
000000r 1               ;;;
000000r 1               ;;; vnIIc Client Application
000000r 1               ;;;
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               
000000r 1                       PADDLE_SUPPORT = 1
000000r 1                       MOUSE_SUPPORT  = 1
000000r 1               
000000r 1                       .include "apple2.inc"
000000r 2               
000000r 2               ;-----------------------------------------------------------------------------
000000r 2               ; Zero page stuff
000000r 2               
000000r 2               WNDLFT  :=      $20     ; Text window left
000000r 2               WNDWDTH :=      $21     ; Text window width
000000r 2               WNDTOP  :=      $22     ; Text window top
000000r 2               WNDBTM  :=      $23     ; Text window bottom+1
000000r 2               CH      :=      $24     ; Cursor horizontal position
000000r 2               CV      :=      $25     ; Cursor vertical position
000000r 2               BASL    :=      $28     ; Text base address low
000000r 2               BASH    :=      $29     ; Text base address high
000000r 2               INVFLG  :=      $32     ; Normal/inverse(/flash)
000000r 2               PROMPT  :=      $33     ; Used by GETLN
000000r 2               RNDL    :=      $4E     ; Random counter low
000000r 2               RNDH    :=      $4F     ; Random counter high
000000r 2               HIMEM   :=      $73     ; Highest available memory address+1
000000r 2               
000000r 2               ;-----------------------------------------------------------------------------
000000r 2               ; Vectors
000000r 2               
000000r 2               DOSWARM :=      $03D0   ; DOS warmstart vector
000000r 2               BRKVec  :=      $03F0   ; Break vector
000000r 2               SOFTEV  :=      $03F2   ; Vector for warm start
000000r 2               PWREDUP :=      $03F4   ; This must be = EOR #$A5 of SOFTEV+1
000000r 2               
000000r 2               ;-----------------------------------------------------------------------------
000000r 2               ; Hardware
000000r 2               
000000r 2               ; Keyboard input
000000r 2               KBD     :=      $C000   ; Read keyboard
000000r 2               KBDSTRB :=      $C010   ; Clear keyboard strobe
000000r 2               
000000r 2               ; 80 column video switches
000000r 2               CLR80COL:=      $C000   ; Disable 80 column store
000000r 2               SET80COL:=      $C001   ; Enable 80 column store
000000r 2               RD80COL :=      $C018   ; >127 if 80 column store enabled
000000r 2               RD80VID :=      $C01F   ; >127 if 80 column video enabled
000000r 2               
000000r 2               ; Character set switches
000000r 2               CLRALTCHAR :=   $C00E   ; Normal Apple II char set
000000r 2               SETALTCHAR :=   $C00F   ; Norm/inv LC, no flash
000000r 2               ALTCHARSET :=   $C01E   ; >127 if alt charset switched in
000000r 2               
000000r 2               ; Language card switches
000000r 2               RDLCBNK2:=      $C011   ; >127 if LC bank 2 in use
000000r 2               RDLCRAM :=      $C012   ; >127 if LC is read enabled
000000r 2               ROMIN   :=      $C081   ; Swap in D000-FFFF ROM
000000r 2               LCBANK2 :=      $C083   ; Swap in LC bank 2
000000r 2               LCBANK1 :=      $C08B   ; Swap in LC bank 1
000000r 2               
000000r 2               ; Video mode switches
000000r 2               TXTCLR  :=      $C050   ; Display graphics
000000r 2               TXTSET  :=      $C051   ; Display text
000000r 2               MIXCLR  :=      $C052   ; Disable 4 lines of text
000000r 2               MIXSET  :=      $C053   ; Enable 4 lines of text
000000r 2               LOWSCR  :=      $C054   ; Page 1
000000r 2               HISCR   :=      $C055   ; Page 2
000000r 2               LORES   :=      $C056   ; Lores graphics
000000r 2               HIRES   :=      $C057   ; Hires graphics
000000r 2               
000000r 2               ; Game controller
000000r 2               BUTN0   :=      $C061   ; Open-Apple Key
000000r 2               BUTN1   :=      $C062   ; Closed-Apple Key
000000r 2               
000000r 1               
000000r 1                       .include "macros.inc"
000000r 2               ;;;---------------------------------------------------------
000000r 2               ;;;
000000r 2               ;;; Generic Macros
000000r 2               ;;;
000000r 2               ;;;---------------------------------------------------------
000000r 2               
000000r 2               .macro SaveRegisters
000000r 2                       pha
000000r 2                       txa
000000r 2                       pha
000000r 2                       tya
000000r 2                       pha
000000r 2               .endmacro
000000r 2               
000000r 2               .macro RestoreRegisters
000000r 2                       pla
000000r 2                       tay
000000r 2                       pla
000000r 2                       tax
000000r 2                       pla
000000r 2               .endmacro
000000r 2               
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Hi-res graphics constants/locations
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               PAGE    := $E6                  ; Active hires plotting page (Applesoft)
000000r 1               PAGE1   := $20
000000r 1               PAGE2   := $40
000000r 1               
000000r 1               PAGESIZE        := $20            ; Size of hi-res screen in pages
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; ROM routines
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               PREAD   := $FB1E                  ; Monitor paddle reading routine, call
000000r 1                                               ; with paddle # in X, returns value in Y
000000r 1               
000000r 1               HCLR    := $F3F2                      ; Clear current hires screen to black
000000r 1               
000000r 1               ;;;---------------------------------------------------------
000000r 1               ;;; Other
000000r 1               ;;;---------------------------------------------------------
000000r 1               
000000r 1               MAX_SLOT        := 7             ; Maximum slot # on an Apple II
000000r 1               
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               ;;; Protocol:
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               
000000r 1               .proc Protocol
000000r 1                       Keyboard := $00
000000r 1               
000000r 1                       Button0  := $10
000000r 1                       Button1  := $11
000000r 1               
000000r 1                       Paddle0  := $20
000000r 1                       Paddle1  := $21
000000r 1               
000000r 1                       MouseX   := $30
000000r 1                       MouseY   := $31
000000r 1                       MouseBtn := $32
000000r 1               
000000r 1                       Screen   := $80
000000r 1               .endproc
000000r 1               
000000r 1               
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               ;;;
000000r 1               ;;; Client Code
000000r 1               ;;;
000000r 1               ;;;-------------------------------------------------------------------
000000r 1               
000000r 1                       .org $6000
006000  1  4C 8A 61             jmp     AppEntry
006003  1               
006003  1                       .include "ssc.inc"
006003  2               ;;;-------------------------------------------------------------------
006003  2               ;;;
006003  2               ;;; Serial port routines
006003  2               ;;;
006003  2               ;;; (based on ADTPro)
006003  2               ;;;
006003  2               ;;;-------------------------------------------------------------------
006003  2               
006003  2               .proc SSC
006003  2               
006003  2               ;;;---------------------------------------------------------
006003  2               ;;; Super Serial constants/locations
006003  2               ;;;---------------------------------------------------------
006003  2               
006003  2               ;;; These get incremented by the slot where they appear
006003  2                       UACTRL = $C08B          ; Control Register
006003  2                       UACMND = $C08A          ; Command Register
006003  2                       UASTAT = $C089          ; Status Register
006003  2                       UADATA = $C088          ; Data Register - incoming and outgoing data
006003  2               
006003  2               ;;; Lookup table for UACTRL register, by baud rate
006003  2               
006003  2  16 1E 1F 10  BPSCTRL:        .byte   $16,$1E,$1F,$10 ; 300, 9600, 19200, 115k (with 8 data bits, 1 stop bit, no echo)
006007  2                       .enum
006007  2                       BPS_300
006007  2                       BPS_9600
006007  2                       BPS_19200
006007  2                       BPS_115k
006007  2                       .endenum
006007  2               
006007  2                       CMND_NRDI = $0B         ; Command: no parity, RTS on, DTR on, no interrupts
006007  2               
006007  2               
006007  2               ;;;---------------------------------------------------------
006007  2               ;;; Initialize the SSC; slot passed in A
006007  2               
006007  2               .proc Init
006007  2  0A                   asl                     ; Slot passed in A
006008  2  0A                   asl
006009  2  0A                   asl
00600A  2  0A                   asl                     ; Now $S0
00600B  2  69 88                adc     #$88            ; Low byte of UADATA
00600D  2  AA                   tax
00600E  2  A9 0B                lda     #CMND_NRDI      ; Command register: no parity, RTS on, DTR on, no interrupts
006010  2  9D 02 C0             sta     $C002,X
006013  2  AC 87 61             ldy     PSPEED          ; Control register: look up by baud rate (8 data bits, 1 stop bit)
006016  2  B9 03 60             lda     BPSCTRL,Y
006019  2  9D 03 C0             sta     $C003,X
00601C  2  8E 3C 60             stx     MOD_UADATA_1    ; Modify references to
00601F  2  8E 49 60             stx     MOD_UADATA_2    ; UADATA to point at
006022  2  8E 55 60             stx     MOD_UADATA_3    ; correct slot (UADATA+S0)
006025  2  E8                   inx
006026  2  8E 32 60             stx     MOD_UASTAT_1    ; Modify reference to
006029  2  8E 40 60             stx     MOD_UASTAT_2    ; UASTAT to point at
00602C  2  8E 4D 60             stx     MOD_UASTAT_3    ; correct slot (UASTAT+S0)
00602F  2  60                   rts
006030  2               .endproc
006030  2               
006030  2               
006030  2               ;;;---------------------------------------------------------
006030  2               ;;; Send accumulator out the serial port
006030  2               
006030  2               .proc Put
006030  2  48                   pha                     ; Push A onto the stack
006031  2               MOD_UASTAT_1    := *+1
006031  2  AD 89 C0     :       lda     UASTAT          ; Check status bits
006034  2  29 70                and     #$70
006036  2  C9 10                cmp     #$10
006038  2  D0 F7                bne     :-              ; Output register is full, so loop
00603A  2  68                   pla
00603B  2               MOD_UADATA_1    := *+1
00603B  2  8D 88 C0             sta     UADATA          ; Put character
00603E  2  60                   rts
00603F  2               .endproc
00603F  2               MOD_UASTAT_1    := Put::MOD_UASTAT_1
00603F  2               MOD_UADATA_1    := Put::MOD_UADATA_1
00603F  2               
00603F  2               ;;;---------------------------------------------------------
00603F  2               ;;; Read a character from the serial port to the accumulator
00603F  2               
00603F  2               .proc Get
00603F  2               MOD_UASTAT_2    := *+1
00603F  2  AD 89 C0             lda     UASTAT          ; Check status bits
006042  2  29 68                and     #$68
006044  2  C9 08                cmp     #$8
006046  2  D0 F7                bne     Get             ; Input register empty, loop
006048  2               MOD_UADATA_2    := *+1
006048  2  AD 88 C0             lda     UADATA          ; Get character
00604B  2  60                   rts
00604C  2               .endproc
00604C  2               MOD_UASTAT_2    := Get::MOD_UASTAT_2
00604C  2               MOD_UADATA_2    := Get::MOD_UADATA_2
00604C  2               
00604C  2               ;;;---------------------------------------------------------
00604C  2               ;;; Check if the serial port has pending data
00604C  2               
00604C  2               .proc HasData
00604C  2               MOD_UASTAT_3    := *+1
00604C  2  AD 89 C0             lda     UASTAT          ; Check status bits
00604F  2  29 68                and     #$68
006051  2  C9 08                cmp     #$8
006053  2  60                   rts
006054  2               .endproc
006054  2               MOD_UASTAT_3    := HasData::MOD_UASTAT_3
006054  2               
006054  2               
006054  2               ;;;---------------------------------------------------------
006054  2               ;;; Clean up serial port
006054  2               
006054  2               .proc Reset
006054  2               MOD_UADATA_3    := *+1
006054  2  2C 88 C0             bit     UADATA
006057  2  60                   rts
006058  2               .endproc
006058  2               MOD_UADATA_3    := Reset::MOD_UADATA_3
006058  2               
006058  2               .endproc
006058  2               
006058  1               
006058  1                   .ifdef MOUSE_SUPPORT
006058  1                       .include "mouse.inc"
006058  2               ;;;-------------------------------------------------------------------
006058  2               ;;;
006058  2               ;;; Mouse
006058  2               ;;;
006058  2               ;;;-------------------------------------------------------------------
006058  2                       ;;         .error "Mouse support not fully implemented"
006058  2               
006058  2               .proc Mouse
006058  2               
006058  2               ;;;--------------------------------------------------
006058  2               ;;; Mouse Screen Holes
006058  2               ;;;--------------------------------------------------
006058  2               
006058  2               ;;; For ReadMouse and PosMouse
006058  2               
006058  2               MOUSE_X_LSB     := $0478        ; + slot        Low byte of X coordinate
006058  2               MOUSE_Y_LSB     := $04F8        ; + slot        Low byte of Y coordinate
006058  2               MOUSE_X_MSB     := $0578        ; + slot        High byte of X coordinate
006058  2               MOUSE_Y_MSB     := $05F8        ; + slot        High byte of Y coordinate
006058  2               MOUSE_RSV1      := $0678        ; + slot        Reserved
006058  2               MOUSE_RSV2      := $06F8        ; + slot        Reserved
006058  2               MOUSE_STATUS    := $0778        ; + slot        Status byte
006058  2                       ;; 7    Button down
006058  2                       ;; 6    Button was down on last read and still down
006058  2                       ;; 5    Movement since last read
006058  2                       ;; 4    Reserved
006058  2                       ;; 3    Interrupt from VBlInt
006058  2                       ;; 2    Interrupt from button
006058  2                       ;; 1    Interrupt from movement
006058  2                       ;; 0    Reserved
006058  2               MOUSE_MODE      := $07F8        ; + slot        Mode byte
006058  2                       ;; 7-4  Reserved
006058  2                       ;; 3    VBlInt active
006058  2                       ;; 2    VBL interrupt on button
006058  2                       ;; 1    VBL interrupt on movement
006058  2                       ;; 0    Mouse active
006058  2               
006058  2               ;;; Scratch area for ClampMouse:
006058  2               
006058  2               MOUSE_CMIN_LSB  := $0478        ; Low byte of clamping minimum
006058  2               MOUSE_CMAX_LSB  := $04F8        ; Low byte of clamping maximum
006058  2               MOUSE_CMIN_MSB  := $0578        ; High byte of clamping minimum
006058  2               MOUSE_CMAX_MSB  := $05F8        ; High byte of clamping maximum
006058  2               
006058  2               ;;;--------------------------------------------------
006058  2               ;;; Mouse Constants
006058  2               ;;;--------------------------------------------------
006058  2               
006058  2               MOUSE_CLAMP_X   := 0            ; Value for A when setting X clamp with ClampMouse
006058  2               MOUSE_CLAMP_Y   := 1            ; Value for A when setting X clamp with ClampMouse
006058  2               
006058  2               ;;; Mouse ID bytes
006058  2               MOUSEID_MAX     := 4
006058  2  05 07 0B 0C  MOUSEID_ADDR:   .byte   $05, $07, $0b, $0c, $fb
00605C  2  FB           
00605D  2  38 18 01 20  MOUSEID_VAL:    .byte   $38, $18, $01, $20, $d6
006061  2  D6           
006062  2               
006062  2               SLOT_BASE       := $C000
006062  2               
006062  2               ;;;--------------------------------------------------
006062  2               ;;; Mouse firmware routine
006062  2               ;;;--------------------------------------------------
006062  2               
006062  2               SetMouse        := $12          ; A=mode; C=0 on success
006062  2               ServeMouse      := $13          ; C=0 mouse interrupt, C=1 other
006062  2               ReadMouse       := $14
006062  2               ClearMouse      := $15
006062  2               PosMouse        := $16
006062  2               ClampMouse      := $17
006062  2               HomeMouse       := $18
006062  2               InitMouse       := $19
006062  2               
006062  2               .macro MOUSE_CALL routine
006062  2                       ldy     routine
006062  2                       jmp     CallMouse
006062  2               .endmacro
006062  2               
006062  2               ;;;--------------------------------------------------
006062  2               ;;; Data
006062  2               ;;;--------------------------------------------------
006062  2               
006062  2               ;;; Mouse
006062  2  00           mouse_slot:     .byte   0       ; mouse slot, or 0 if none
006063  2  00           mouse_fw_hi:    .byte   0       ; mouse slot as $Cn
006064  2  00           mouse_op:       .byte   0       ; mouse slot as $n0
006065  2               
006065  2               mouse_ptr       := $EB          ; Zero page location
006065  2               
006065  2               ;;;--------------------------------------------------
006065  2               ;;; Routines
006065  2               ;;;--------------------------------------------------
006065  2               
006065  2               
006065  2               MOUSE_CLAMP_MIN := $10
006065  2               MOUSE_CLAMP_MAX := $1F
006065  2               MOUSE_CENTER    := $17
006065  2               MOUSE_POS_MASK  := $0F
006065  2               
006065  2               
006065  2               ;;;--------------------------------------------------
006065  2               ;;; Macros for common mouse operations
006065  2               ;;;--------------------------------------------------
006065  2               
006065  2               ;;;----------------------------------------
006065  2               .macro DoClampMouse   axis, min, max
006065  2               ;;;----------------------------------------
006065  2               ;;; axis: MOUSE_CLAMP_X or MOUSE_CLAMP_Y
006065  2               ;;; min:  minimum value (2 byte)
006065  2               ;;; max:  maximum value (2 byte)
006065  2               ;;;----------------------------------------
006065  2                       lda     #<min
006065  2                       sta     MOUSE_CMIN_LSB
006065  2                       lda     #>min
006065  2                       sta     MOUSE_CMIN_MSB
006065  2                       lda     #<max
006065  2                       sta     MOUSE_CMAX_LSB
006065  2                       lda     #>max
006065  2                       sta     MOUSE_CMAX_MSB
006065  2                       lda     #axis
006065  2                       MOUSE_CALL ClampMouse
006065  2               .endmacro
006065  2               
006065  2               ;;;----------------------------------------
006065  2               .macro DoPosMouse   px, py
006065  2               ;;;----------------------------------------
006065  2                       ldx     mouse_slot
006065  2                       lda     #<px
006065  2                       sta     MOUSE_X_LSB,x
006065  2                       lda     #>px
006065  2                       sta     MOUSE_X_MSB,x
006065  2                       lda     #<py
006065  2                       sta     MOUSE_Y_LSB,x
006065  2                       lda     #>py
006065  2                       sta     MOUSE_Y_MSB,x
006065  2                       MOUSE_CALL PosMouse
006065  2               .endmacro
006065  2               
006065  2               ;;;----------------------------------------
006065  2               .macro DoSetMouse   mode
006065  2               ;;;----------------------------------------
006065  2                       lda     #mode
006065  2                       MOUSE_CALL SetMouse
006065  2               .endmacro
006065  2               
006065  2               
006065  2               ;;;---------------------------------------------------------
006065  2               ;;; Find and initialize the mouse port
006065  2               
006065  2               .proc FindMouse
006065  2               
006065  2               ;;; Reference: http://home.swbell.net/rubywand/R034MOUSEPRG.TXT
006065  2               
006065  2  78                   sei                     ; No interrupts while we're getting set up
006066  2               
006066  2                       ;; Find mouse card by scanning slots for ID bytes
006066  2               
006066  2  A0 07                ldy     #MAX_SLOT       ; Start search in slot 7
006068  2               
006068  2               slot_loop:
006068  2  8C 62 60             sty     mouse_slot      ; Save for later
00606B  2  98                   tya
00606C  2  18                   clc
00606D  2  69 C0                adc     #>SLOT_BASE     ; Firmware is $Cn
00606F  2  8D 7C 60             sta     slot_addr + 1   ; Update msb of signature test
006072  2  A2 04                ldx     #MOUSEID_MAX    ; This many signature bytes
006074  2               
006074  2  BD 58 60     :       lda     MOUSEID_ADDR,x
006077  2  8D 7B 60             sta     slot_addr       ; Update lsb of signature test
00607A  2               
00607A  2               slot_addr       := *+1
00607A  2  AD 00 C0             lda     SLOT_BASE       ; Self-modified
00607D  2  DD 5D 60             cmp     MOUSEID_VAL,x   ; Does it match the signature?
006080  2  D0 06                bne     no_match        ; Nope - try the next slot
006082  2  CA                   dex                     ; Yes! Keep testing
006083  2  10 EF                bpl     :-              ; Fall through if all done
006085  2  4C 8F 60             jmp     found
006088  2               
006088  2               no_match:
006088  2  88                   dey                     ; Didn't match
006089  2  D0 DD                bne     slot_loop       ; Keep looking until slot 0
00608B  2  8C 62 60             sty     mouse_slot      ; Oops, no mouse - make a note
00608E  2  60                   rts                     ; and bail
00608F  2               
00608F  2                       ;; Store results needed for call ($Cn and $n0)
00608F  2               
00608F  2  98           found:  tya                     ; Slot is in y
006090  2  09 C0                ora     #>SLOT_BASE     ; Compute $Cn - needed for calls
006092  2  8D 63 60             sta     mouse_fw_hi
006095  2               
006095  2  98                   tya
006096  2  0A                   asl                     ; Compute $n0 - needed for calls
006097  2  0A                   asl
006098  2  0A                   asl
006099  2  0A                   asl
00609A  2  8D 64 60             sta     mouse_op
00609D  2               
00609D  2                       ;; Initialize and configure mouse card
00609D  2               
00609D  2  A4 19 4C FD          MOUSE_CALL InitMouse    ; reset, clamp to 0-1023 x/y
0060A1  2  60           
0060A2  2               
0060A2  2  A9 01 A4 12          DoSetMouse $01          ; mouse on, no interrupts
0060A6  2  4C FD 60     
0060A9  2                                               ; TODO: test carry bit result (set = error)
0060A9  2               
0060A9  2                       ;; Clamp for deltas
0060A9  2  A9 10 8D 78          DoClampMouse MOUSE_CLAMP_X, MOUSE_CLAMP_MIN, MOUSE_CLAMP_MAX
0060AD  2  04 A9 00 8D  
0060B1  2  78 05 A9 1F  
0060B5  2  8D F8 04 A9  
0060B9  2  00 8D F8 05  
0060BD  2  A9 00 A4 17  
0060C1  2  4C FD 60     
0060C4  2  A9 10 8D 78          DoClampMouse MOUSE_CLAMP_Y, MOUSE_CLAMP_MIN, MOUSE_CLAMP_MAX
0060C8  2  04 A9 00 8D  
0060CC  2  78 05 A9 1F  
0060D0  2  8D F8 04 A9  
0060D4  2  00 8D F8 05  
0060D8  2  A9 01 A4 17  
0060DC  2  4C FD 60     
0060DF  2               
0060DF  2  AE 62 60 A9          DoPosMouse MOUSE_CENTER, MOUSE_CENTER
0060E3  2  17 9D 78 04  
0060E7  2  A9 00 9D 78  
0060EB  2  05 A9 17 9D  
0060EF  2  F8 04 A9 00  
0060F3  2  9D F8 05 A4  
0060F7  2  16 4C FD 60  
0060FB  2               
0060FB  2  58                   cli                     ; Enable interrupts so mouse can function
0060FC  2               
0060FC  2  60                   rts
0060FD  2               .endproc
0060FD  2               
0060FD  2               ;;;--------------------------------------------------
0060FD  2               ;;; Call mouse firmware, param in A, routine in Y
0060FD  2               
0060FD  2               .proc CallMouse
0060FD  2  48                   pha                     ; Save A (param)
0060FE  2  AE 63 60             ldx     mouse_fw_hi     ; $Cn
006101  2  86 EC                stx     mouse_ptr+1
006103  2  A9 00                lda     #0
006105  2  85 EB                sta     mouse_ptr
006107  2  B1 EB                lda     (mouse_ptr),y  ; Look up routine offset
006109  2  85 EB                sta     mouse_ptr
00610B  2               
00610B  2  68                   pla                     ; param in A
00610C  2  AC 64 60             ldy     mouse_op        ; $n0 in Y
00610F  2               
00610F  2  08                   php
006110  2  78                   sei
006111  2  20 16 61             jsr     call
006114  2  28                   plp
006115  2  60                   rts
006116  2               
006116  2  6C EB 00     call:   jmp     (mouse_ptr)
006119  2               .endproc
006119  2               
006119  2               ;;;--------------------------------------------------
006119  2               ;;; Read mouse pos, send deltas, and recenter
006119  2               
006119  2               .proc SendMouse
006119  2  48 8A 48 98          SaveRegisters
00611D  2  48           
00611E  2  AD 62 60             lda     mouse_slot
006121  2  F0 5E                beq     done
006123  2               
006123  2  A4 14 4C FD          MOUSE_CALL ReadMouse
006127  2  60           
006128  2               
006128  2  A5 30                lda     Protocol::MouseX
00612A  2  20 30 60             jsr     SSC::Put
00612D  2  A9 01                lda     #1              ; Data size
00612F  2  20 30 60             jsr     SSC::Put
006132  2  AE 62 60             ldx     mouse_slot
006135  2  BD 78 04             lda     MOUSE_X_LSB,x
006138  2  05 0F                ora     MOUSE_POS_MASK
00613A  2  20 30 60             jsr     SSC::Put
00613D  2               
00613D  2  A5 31                lda     Protocol::MouseY
00613F  2  20 30 60             jsr     SSC::Put
006142  2  A9 01                lda     #1              ; Data size
006144  2  20 30 60             jsr     SSC::Put
006147  2  AE 62 60             ldx     mouse_slot
00614A  2  BD F8 04             lda     MOUSE_Y_LSB,x
00614D  2  05 0F                ora     MOUSE_POS_MASK
00614F  2  20 30 60             jsr     SSC::Put
006152  2               
006152  2  A5 32                lda     Protocol::MouseBtn
006154  2  20 30 60             jsr     SSC::Put
006157  2  A9 01                lda     #1              ; Data size
006159  2  20 30 60             jsr     SSC::Put
00615C  2  AE 62 60             ldx     mouse_slot
00615F  2  BD 78 07             lda     MOUSE_STATUS,x
006162  2  20 30 60             jsr     SSC::Put
006165  2               
006165  2  AE 62 60 A9          DoPosMouse MOUSE_CENTER, MOUSE_CENTER
006169  2  17 9D 78 04  
00616D  2  A9 00 9D 78  
006171  2  05 A9 17 9D  
006175  2  F8 04 A9 00  
006179  2  9D F8 05 A4  
00617D  2  16 4C FD 60  
006181  2               
006181  2  68 A8 68 AA  done:   RestoreRegisters
006185  2  68           
006186  2  60                   rts
006187  2               .endproc
006187  2               
006187  2               .endproc
006187  2               
006187  1                   .endif
006187  1               
006187  1               
006187  1               ;;;-------------------------------------------------------------------
006187  1               ;;; Variables
006187  1               ;;;-------------------------------------------------------------------
006187  1               
006187  1               ;;; Application configuration
006187  1  03           PSPEED: .byte   SSC::BPS_115k   ; Hardcoded for Apple IIc (TODO: Allow configuration)
006188  1  02           PSLOT:  .byte   2               ; Hardcoded for Apple IIc (TODO: Allow configuration)
006189  1  00           PEXIT:  .byte   0               ; Set when it's time to exit (Not Yet Implemented)
00618A  1               
00618A  1               
00618A  1               ;;;---------------------------------------------------------
00618A  1               ;;; Initialize the application, and enter the main loop
00618A  1               
00618A  1               .proc AppEntry
00618A  1  AD 88 61             lda     PSLOT           ; Use slot 2
00618D  1  20 07 60             jsr     SSC::Init       ; Initialize Super Serial Card
006190  1  20 60 62             jsr     InitHires       ; Initialize Hi-Res graphics
006193  1  20 D4 61             jsr     InitInput       ; Initialize input devices
006196  1  20 A3 61             jsr     MainLoop
006199  1                       ;; fall through
006199  1               .endproc
006199  1               
006199  1               ;;;---------------------------------------------------------
006199  1               ;;; Clean up and exit app
006199  1               
006199  1               .proc AppExit
006199  1  20 54 60             jsr     SSC::Reset
00619C  1  8D 54 C0             sta     LOWSCR
00619F  1  8D 51 C0             sta     TXTSET
0061A2  1  60                   rts
0061A3  1               .endproc
0061A3  1               
0061A3  1               ;;;-------------------------------------------------------------------
0061A3  1               ;;;
0061A3  1               ;;; Main loop functionality
0061A3  1               ;;;
0061A3  1               ;;;-------------------------------------------------------------------
0061A3  1               
0061A3  1               
0061A3  1               ;;;---------------------------------------------------------
0061A3  1               .proc MainLoop
0061A3  1               
0061A3  1               ;;; TODO: Sort out the protocol - should be able to send
0061A3  1               ;;; input state without receiving data
0061A3  1               ;;;    jsr SSC::HasData      ; Anything to read?
0061A3  1               ;;;    bne :+              ; Nope
0061A3  1               
0061A3  1  20 AD 61     :       jsr     ReceivePage
0061A6  1                       ;; Input is sent every 256 bytes (32 times per page)
0061A6  1  20 77 62             jsr     FlipHires
0061A9  1               
0061A9  1  4C A3 61             jmp     :-              ; TODO: define an exit trigger
0061AC  1  60                   rts
0061AD  1               .endproc
0061AD  1               
0061AD  1               
0061AD  1               ;;;---------------------------------------------------------
0061AD  1               ;;; Request a hires page, sending input state along every
0061AD  1               ;;; 256 bytes.
0061AD  1               ;;;
0061AD  1               
0061AD  1               .proc ReceivePage
0061AD  1               
0061AD  1               ptr     := $FA
0061AD  1               
0061AD  1  A9 80                lda     #Protocol::Screen
0061AF  1  20 30 60             jsr     SSC::Put
0061B2  1  A9 00                lda     #0              ; data size
0061B4  1  20 30 60             jsr     SSC::Put
0061B7  1               
0061B7  1               
0061B7  1  A9 00                lda     #0              ; set up write pointer
0061B9  1  85 FA                sta     ptr
0061BB  1  A5 E6                lda     PAGE
0061BD  1  85 FB                sta     ptr+1
0061BF  1  A2 20                ldx     #PAGESIZE       ; plan to receive this many pages
0061C1  1  A0 00                ldy     #0
0061C3  1               
0061C3  1  20 3F 60     :       jsr     SSC::Get
0061C6  1  91 FA                sta     (ptr),Y
0061C8  1  C8                   iny
0061C9  1  D0 F8                bne     :-              ; Do a full page...
0061CB  1               
0061CB  1                       ;; Interleave to maintain responsiveness
0061CB  1  20 D8 61             jsr     SendInputState
0061CE  1               
0061CE  1  E6 FB                inc     ptr+1
0061D0  1  CA                   dex
0061D1  1  D0 F0                bne     :-              ; ...as many pages as we need
0061D3  1  60                   rts
0061D4  1               .endproc
0061D4  1               
0061D4  1               
0061D4  1               ;;;-------------------------------------------------------------------
0061D4  1               ;;;
0061D4  1               ;;; Input device routines
0061D4  1               ;;;
0061D4  1               ;;;-------------------------------------------------------------------
0061D4  1               
0061D4  1               ;;;---------------------------------------------------------
0061D4  1               ;;; Initialize input devices and storage for detecting
0061D4  1               ;;; state transitions
0061D4  1               
0061D4  1               .proc InitInput
0061D4  1               
0061D4  1                   .ifdef MOUSE_SUPPORT
0061D4  1  20 65 60             jsr     Mouse::FindMouse
0061D7  1                   .endif
0061D7  1               
0061D7  1  60                   rts
0061D8  1               .endproc
0061D8  1               
0061D8  1               
0061D8  1               ;;;---------------------------------------------------------
0061D8  1               ;;; Send a full set of input state updates.
0061D8  1               
0061D8  1               ;;; Assumes time to transmit is roughly comparable to time
0061D8  1               ;;; to measure input state, therefore only sending changes is
0061D8  1               ;;; not worthwhile in most cases.
0061D8  1               
0061D8  1               .proc SendInputState
0061D8  1  20 E5 61             jsr     MaybeSendKeyboard
0061DB  1  20 18 62             jsr     SendButtons
0061DE  1               
0061DE  1                   .ifdef PADDLE_SUPPORT
0061DE  1  20 39 62             jsr     SendPaddles
0061E1  1                   .endif
0061E1  1               
0061E1  1                   .ifdef MOUSE_SUPPORT
0061E1  1  20 19 61             jsr     Mouse::SendMouse
0061E4  1                   .endif
0061E4  1               
0061E4  1               .endproc
0061E4  1               
0061E4  1               
0061E4  1               ;;;------------------------------------------------------------
0061E4  1               ;;; Keyboard
0061E4  1               
0061E4  1               ;;; NOTE: Can't use KBDSTRB to detect key up -> key down transition
0061E4  1               ;;; since the msb can change before the key code. Instead, consider
0061E4  1               ;;; these cases:
0061E4  1               ;;;
0061E4  1               ;;;  OLD STATE    KBD       KBDSTRB    RESULT
0061E4  1               ;;;   Up           Up        -          No-op
0061E4  1               ;;;   Up           Down      -          Save and send key down
0061E4  1               ;;;   Down         -         Up         Save and send key up
0061E4  1               ;;;   Down         -         Down       Save and send key ONLY if different
0061E4  1               ;;;
0061E4  1               
0061E4  1  00           last_kb:        .byte   0
0061E5  1               
0061E5  1               .proc MaybeSendKeyboard
0061E5  1  AD E4 61             lda     last_kb
0061E8  1  D0 08                bne     key_was_down
0061EA  1               
0061EA  1               key_was_up:
0061EA  1                       ;; Key was up - send only if now down.
0061EA  1  AD 00 C0             lda     KBD             ; Read keyboard
0061ED  1  10 28                bpl     done            ; Do nothing if it is still up.
0061EF  1  4C 04 62             jmp     send            ; Otherwise send.
0061F2  1               
0061F2  1               key_was_down:
0061F2  1                       ;; Key was down - strobe should match
0061F2  1                       ;; unless the key changed or was released.
0061F2  1  AD 10 C0             lda     KBDSTRB
0061F5  1  30 05                bmi     kbdstrb_down
0061F7  1               
0061F7  1               kbdstrb_up:
0061F7  1  A9 00                lda     #0              ; Now released
0061F9  1  4C 04 62             jmp     send
0061FC  1               
0061FC  1               kbdstrb_down:
0061FC  1  CD E4 61             cmp     last_kb         ; Same key as last time?
0061FF  1  F0 16                beq     done            ; - no change, don't send.
006201  1  4C 04 62             jmp     send
006204  1               
006204  1  8D E4 61     send:   sta     last_kb
006207  1  A5 00                lda     Protocol::Keyboard
006209  1  20 30 60             jsr     SSC::Put
00620C  1  A9 01                lda     #1              ; Data size
00620E  1  20 30 60             jsr     SSC::Put
006211  1  AD E4 61             lda     last_kb
006214  1  20 30 60             jsr     SSC::Put
006217  1               
006217  1  60           done:   rts
006218  1               .endproc
006218  1               
006218  1               ;;;------------------------------------------------------------
006218  1               ;;; Buttons
006218  1               
006218  1               .proc SendButtons
006218  1               
006218  1  A5 10                lda     Protocol::Button0
00621A  1  20 30 60             jsr     SSC::Put
00621D  1  A9 01                lda     #1              ; Data size
00621F  1  20 30 60             jsr     SSC::Put
006222  1  AD 61 C0             lda     BUTN0
006225  1  20 30 60             jsr     SSC::Put
006228  1               
006228  1  A5 11                lda     Protocol::Button1
00622A  1  20 30 60             jsr     SSC::Put
00622D  1  A9 01                lda     #1              ; Data size
00622F  1  20 30 60             jsr     SSC::Put
006232  1  AD 62 C0             lda     BUTN1
006235  1  20 30 60             jsr     SSC::Put
006238  1               
006238  1  60                   rts
006239  1               .endproc
006239  1               
006239  1               ;;;------------------------------------------------------------
006239  1               ;;; Paddles
006239  1               
006239  1                   .ifdef PADDLE_SUPPORT
006239  1               .proc SendPaddles
006239  1               
006239  1  A5 20                lda     Protocol::Paddle0
00623B  1  20 30 60             jsr     SSC::Put
00623E  1  A9 01                lda     #1              ; Data size
006240  1  20 30 60             jsr     SSC::Put
006243  1               
006243  1  A2 00                ldx     #0
006245  1  20 1E FB             jsr     PREAD
006248  1  98                   tya
006249  1  20 30 60             jsr     SSC::Put
00624C  1               
00624C  1                       ;; Need to wait 3ms between reads.
00624C  1               
00624C  1  A5 21                lda     Protocol::Paddle1
00624E  1  20 30 60             jsr     SSC::Put
006251  1  A9 01                lda     #1              ; Data size
006253  1  20 30 60             jsr     SSC::Put
006256  1               
006256  1  A2 01                ldx     #1
006258  1  20 1E FB             jsr     PREAD
00625B  1  98                   tya
00625C  1  20 30 60             jsr     SSC::Put
00625F  1               
00625F  1  60                   rts
006260  1               .endproc
006260  1                   .endif
006260  1               
006260  1               ;;;-------------------------------------------------------------------
006260  1               ;;;
006260  1               ;;; Hi-res graphics routines
006260  1               ;;;
006260  1               ;;;-------------------------------------------------------------------
006260  1               
006260  1               ;;;---------------------------------------------------------
006260  1               ;;; Set up the graphics display and pointers
006260  1               
006260  1               .proc InitHires
006260  1  A9 20                lda     #PAGE1          ; clear page 1
006262  1  85 E6                sta     PAGE
006264  1  20 F2 F3             jsr     HCLR
006267  1               
006267  1  20 77 62             jsr     FlipHires       ; then show it and flip to 2
00626A  1  8D 57 C0             sta     HIRES
00626D  1  8D 50 C0             sta     TXTCLR
006270  1  8D 52 C0             sta     MIXCLR
006273  1  8D 54 C0             sta     LOWSCR
006276  1               
006276  1  60                   rts
006277  1               .endproc
006277  1               
006277  1               
006277  1               ;;;---------------------------------------------------------
006277  1               ;;; Call when done with the current plotting page
006277  1               ;;; (selected in PAGE) and it will be shown and the
006277  1               ;;; other page will be shown.
006277  1               
006277  1               .proc FlipHires
006277  1  A5 E6                lda     PAGE            ; plotting on which page?
006279  1  C9 20                cmp     #PAGE1
00627B  1  F0 08                beq     :+
00627D  1               
00627D  1  8D 55 C0             sta     HISCR           ; page 2 - so show it
006280  1  A9 20                lda     #PAGE1          ; and plot on page 1
006282  1  85 E6                sta     PAGE
006284  1  60                   rts
006285  1               
006285  1  8D 54 C0     :       sta     LOWSCR          ; page 1 - so show it
006288  1  A9 40                lda     #PAGE2          ; and plot on page 2
00628A  1  85 E6                sta     PAGE
00628C  1  60                   rts
00628D  1               .endproc
00628D  1               
